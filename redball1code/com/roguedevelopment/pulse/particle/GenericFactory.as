/** *  Latest information on this project can be found at http://www.rogue-development.com/pulseParticles.xml *  *  Copyright (c) 2008 Marc Hughes  *  *  Permission is hereby granted, free of charge, to any person obtaining a  *  copy of this software and associated documentation files (the "Software"),  *  to deal in the Software without restriction, including without limitation  *  the rights to use, copy, modify, merge, publish, distribute, sublicense,  *  and/or sell copies of the Software, and to permit persons to whom the Software  *  is furnished to do so, subject to the following conditions: *  *  The above copyright notice and this permission notice shall be included in all  *  copies or substantial portions of the Software. *  *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,  *  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A  *  PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT  *  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE  *  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *  * ------------------------------------------------------------------------------------------- *  * Description: *    The Pulse Particle engine gives a simple way to create complex particle effects. *  *  *  **/package com.roguedevelopment.pulse.particle{	import com.roguedevelopment.pulse.initializers.IPulseInitializer;		import flash.display.Sprite;		public final class GenericFactory implements IParticleFactory	{		protected var partClass:Class;		protected var _rules:Array;		protected var _initializers:Array;		protected var recycled:Array = [];		public var isRunning:Boolean = true;				public function GenericFactory( particleClass:Class, rules:Array , initializers:Array)		{			super();			this.partClass = particleClass;			_rules = rules;			this.initializers = initializers;		}		public function set initializers(rules:Array) : void		{			_initializers = rules;		}		public function newParticle():IParticle		{			var particle:IParticle;			isRunning = true;			if( recycled.length > 0 )			{				particle = recycled.shift() as IParticle;				(particle as IRecyleableParticle).recycle();			}			else			{				var obj:Object = new partClass();				if( obj is IParticle )				{			 		particle =  obj as IParticle;			 	}			 	else if ( obj is Sprite )			 	{			 		particle = new GenericParticle();			 		(particle as GenericParticle).addChild( obj as Sprite );				 	}			 												if( particle is IRecyleableParticle )				{					(particle as IRecyleableParticle ).factory = this;				}			}						particle.rules = _rules.concat();						for each( var initRule:IPulseInitializer in _initializers )			{				trace( initRule );				initRule.init( particle );			}						return particle;		}				public function set rules(rules:Array) : void		{			_rules = rules;		}				public function recycle( particle:IParticle ) : void		{			if( isRunning )			{				particle.visible = false;				recycled.push(particle);			}			else			{				particle.remove();			}		}				public function cleanup() : void		{			isRunning = false;			for each ( var p:IParticle in recycled )			{				p.remove();			}			recycled = [];		}			}}